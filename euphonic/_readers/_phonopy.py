import re
import os
import struct
import yaml
import h5py
import glob 

import numpy as np
from euphonic import ureg
from euphonic.util import reciprocal_lattice, is_gamma

#TODO documentation
#TODO test _match_seed
#TODO test _extract_*_data
#TODO test _read_*_data
#TODO phonopy unit conversion, search phonopy.yaml for 'physical_unit'

def _convert_units(data_dict):
    pass

def _match_seed(path, seed='*'):
    """DOC
    Search target path for seed with standard yaml and hdf5 extensions.
    """

    HDF5_EXTS = ['.hdf5', '.he5', '.h5']
    YAML_EXTS = ['.yaml', '.yml']

    file_glob = os.path.join(path, seed + '.*')
    file_globs = glob.glob(file_glob)

    h5_matches = [[name for name in file_globs if h5s in name]
                    for h5s in HDF5_EXTS]
    yml_matches = [[name for name in file_globs if yml in name]
                    for yml in YAML_EXTS]

    if h5_matches: # take the first hdf5 match
        file = h5_matches[0]
    elif yml_matches: # take the first yaml match
        file = yml_matches[0]
    elif seed and seed != '*': # try just seed given by the user
        file = os.path.join(path, seed)
    else:
        return None

    # check that final name exists
    if os.path.exists(file):
        return file
    else:
        return None

def _match_summary(path, config='phonopy.yaml'):
    """ DOC
    Search for the output summary generated by phonopy at the end of the
    workflow when using the commandline interface.
    """

    file = os.path.join(path, config)

    #TODO if user specified name doesn't exist, try default,
    # search all yamls until, then look for ['phonopy']['version']

    if os.path.exists(file):
        return file
    else:
        return None

    pass


def _extract_phonon_data(data_object):
    """ DOC: """

    n_qpts = data_objec['nqpoint']
    n_ions = data_objec['natom']
    cell_vec = data_objec['lattice']
    recip_vec = data_objec['reciprocal_lattice']
    qpts = [phon['q-position'] for phon in data_object['phonon']]

    weights = [phon['weight'] for phon in data_object['phonon']]

    phonon_data = [phon for phon in data_object['phonon']]
    bands_data_each_qpt = [bands_data['band']
                            for bands_data in phonon_data]

    # The frequency for each band at each q-point
    freqs = np.array([ [band_data['frequency']
                            for band_data in bands_data]
                              for bands_data in bands_data_each_qpt])

    # The eigenvector for each atom for each band at each q-point
    eigenvecs = np.array([ [band_data['eigenvector']
                            for band_data in bands_data]
                              for bands_data in bands_data_each_qpt]).view(np.complex128)

    n_branches = freqs.shape[1]

    ion_type = [ion['symbol'] for ion in data_object['points']]
    ion_r = [ion['coordinates'] for ion in data_object['points']]
    ion_mass = [ion['mass'] for ion in data_object['points']]

    #TODO supply units
    data_dict = {}
    data_dict['n_qpts'] = n_qpts
    data_dict['n_spins'] = NotImplemented #n_spins, electronic
    data_dict['n_branches'] = n_branches
    data_dict['fermi'] = NotImplemented #(fermi*ureg.hartree).to('eV'), electronic
    data_dict['cell_vec'] = cell_vec #(cell_vec*ureg.bohr).to('angstrom')
    data_dict['recip_vec'] = recip_vec #((reciprocal_lattice(cell_vec)/ureg.bohr).to('1/angstrom'))
    data_dict['qpts'] = qpts
    data_dict['weights'] = weights #weights
    data_dict['freqs'] = freqs #(freqs*ureg.hartree).to('eV')
    data_dict['freq_down'] = NotImplemented #(freq_down*ureg.hartree).to('eV'), electronic
    data_dict['eigenvecs'] = eigenvecs
    data_dict['n_ions'] = n_ions
    data_dict['ion_r'] = ion_r
    data_dict['ion_type'] = ion_type

    return data_dict

def _read_phonon_data(seedname='mesh', path='.'):
    """
    Reads data from a mesh.yaml/hdf5 file and returns it in a dictionary

    Parameters
    ----------
    seedname : str
        Seedname of file(s) to read
    path : str
        Path to dir containing the file(s), if in another directory

    Returns
    -------
    data_dict : dict
        A dict with the following keys: 'n_ions', 'n_branches', 'n_qpts'
        'cell_vec', 'recip_vec', 'ion_r', 'ion_type', 'ion_mass', 'qpts',
        'weights', 'freqs', 'eigenvecs', 'split_i', 'split_freqs',
        'split_eigenvecs'
    """

    """
    data_dict = {}
    data_dict['n_ions'] = None #n_ions
    data_dict['n_branches'] = None #n_branches
    data_dict['n_qpts'] = None #n_qpts
    data_dict['cell_vec'] = None #cell_vec*ureg.angstrom
    data_dict['recip_vec'] = None #reciprocal_lattice(cell_vec)/ureg.angstrom
    data_dict['ion_r'] = None #ion_r
    data_dict['ion_type'] = None #ion_type
    data_dict['ion_mass'] = None #ion_mass*ureg.amu
    data_dict['qpts'] = None #qpts
    data_dict['weights'] = None #weights
    data_dict['freqs'] = None #(freqs*(1/ureg.cm)).to('meV', 'spectroscopy')
    data_dict['eigenvecs'] = None #eigenvecs
    data_dict['split_i'] = None #split_i
    data_dict['split_freqs'] = None #(split_freqs*(1/ureg.cm)).to('meV', 'spectroscopy')
    data_dict['split_eigenvecs'] = None #split_eigenvecs
    """

    file = _match_seed(path, seed=seed)

    try:
        with h5py.File(file) as hdf5_data:
            return _extract_phonon_data(hdf5_data)
    except:
        pass

    try:
        with open(file) as yaml_obj:
            yaml_data = yaml.safe_load(yaml_obj)
            return _extract_phonon_data(yaml_data)
    except:
        pass

    return None

#TODO
def _extract_force_constants(fc_object):
    """ DOC
    Parse, reshape, and convert FC from FORCE_CONSTANTS
    """
    pass

#TODO
def _extract_force_constants_yaml(fc_object):
    """ DOC
    Retrieve, reshape, and convert FC from phonopy.yaml
    """
    pass

#TODO
def _extract_born(born_object):
    """ DOC
    Parse and convert dielectric tensor and born effective
    charge from BORN file
    """
    pass

#TODO
def _extract_bec_yaml(bec_object):
    """ DOC
    Retrieve and convert born effective charge from phonopy.yaml.
    BEC won't necessarily exist alongside dielectric constant.
    """
    pass

#TODO
def _extract_eps_yaml(eps_object):
    """ DOC
    Retrieve and convert dielectric tensor from phonopy.yaml.
    Eps won't necessarily exist alongside dielectric constant.
    """
    pass


def _extract_interpolation_data(data_object):
    # TODO read phonopy.yaml file alongside
    # TODO read FORCE_CONSTANTS, BORN, phonopy.yaml,
    # any yaml that contains force_constants, born data
    #TODO use Becky's convert scripts for ion position
    #TODO add force constants reference
    #TODO remove dynamical lattice if inappropriate

    n_qpts = data_objec['nqpoint']
    n_ions = data_objec['natom']
    #cell_vec = data_objec['lattice']
    recip_vec = data_objec['reciprocal_lattice']
    qpts = [phon['q-position'] for phon in data_object['phonon']]

    #weights = [phon['weight'] for phon in data_objec['phonon']]

    phonon_data = [phon for phon in data_object['phonon']]
    bands_data_each_qpt = [bands_data['band']
                            for bands_data in phonon_data]

    dyn_mat_data = [phon['dynamical_matrix'] for phon in phonon_data]

    # The frequency for each band at each q-point
    freqs = np.array([ [band_data['frequency']
                            for band_data in bands_data]
                              for bands_data in bands_data_each_qpt])

    n_branches = freqs.shape[1]

    #TODO look for ion references in phonopy.yaml
    #ion_type = [ion['symbol'] for ion in data_objec['points']]
    #ion_r = [ion['coordinates'] for ion in data_objec['points']]
    #ion_mass = [ion['mass'] for ion in data_objec['points']]

    data_dict = {}
    data_dict['dynamical_matrix'] = dyn_mat_data
    data_dict['n_qpts'] = n_qpts
    data_dict['n_branches'] = n_branches
    data_dict['cell_vec'] = NotImplemented #(cell_vec*ureg.bohr).to('angstrom')
    data_dict['recip_vec'] = recip_vec #((reciprocal_lattice(cell_vec)/ureg.bohr).to('1/angstrom'))
    data_dict['qpts'] = qpts
    data_dict['freqs'] = freqs #(freqs*ureg.hartree).to('eV')
    data_dict['n_ions'] = n_ions
    data_dict['ion_r'] = NotImplemented
    data_dict['ion_type'] = NotImplemented

    return data_dict

def _read_interpolation_data(seedname='qpoints', path='.'):
    """
    Reads data from a qpoints.yaml file and returns it in a dictionary

    Parameters
    ----------
    seedname : str
        Seedname of file(s) to read
    path : str
        Path to dir containing the file(s), if in another directory

    Returns
    -------
    data_dict : dict
        A dict with the following keys: 'n_ions', 'n_branches', 'cell_vec',
        'recip_vec', 'ion_r', 'ion_type', 'ion_mass', 'force_constants',
        'sc_matrix', 'n_cells_in_sc' and 'cell_origins'. Also contains 'born'
        and 'dielectric' if they are present in the .castep_bin or .check file
    """

    file = _match_seed(path, seed=seed)

    # extract from all sources before returning object
    try:
        with h5py.File(file) as hdf5_data:
            return _extract_interpolation_data(hdf5_data)
    except:
        pass

    try:
        with open(file) as yaml_obj:
            yaml_data = yaml.safe_load(yaml_obj)
            return _extract_interpolation_data(yaml_data)
    except:
        pass

    data_dict = {}
    data_dict['n_ions'] = NotImplemented #n_ions
    data_dict['n_branches'] = NotImplemented #3*n_ions
    data_dict['cell_vec'] = NotImplemented #(cell_vec*ureg.bohr).to('angstrom')
    data_dict['recip_vec'] = NotImplemented #((reciprocal_lattice(cell_vec)/ureg.bohr).to('1/angstrom'))
    data_dict['ion_r'] = NotImplemented #ion_r - np.floor(ion_r)  # Normalise ion coordinates
    data_dict['ion_type'] = NotImplemented #ion_type
    data_dict['ion_mass'] = NotImplemented #(ion_mass*ureg.e_mass).to('amu')

    # Set entries relating to 'FORCE_CONSTANTS' block
    try:
        data_dict['force_constants'] = NotImplemented #(force_constants*ureg.hartree/(ureg.bohr**2))
        data_dict['sc_matrix'] = NotImplemented #sc_matrix
        data_dict['n_cells_in_sc'] = NotImplemented #n_cells_in_sc
        data_dict['cell_origins'] = NotImplemented #cell_origins
    except NameError:
        raise Exception((
            'Force constants matrix could not be found in {:s}.\n Ensure '
            'PHONON_WRITE_FORCE_CONSTANTS: true has been set when running '
            'CASTEP').format(file))

    # Set entries relating to dipoles
    try:
        data_dict['born'] = NotImplemented #born*ureg.e
        data_dict['dielectric'] = NotImplemented #dielectric
    except UnboundLocalError:
        pass

    data_dict['dynamical_matrix'] = NotImplemented


    return data_dict


#TODO remove bands readers if not needed
def _extract_bands_data(data_object):
    n_qpts = data_objec['nqpoint']
    n_ions = data_objec['natom']
    cell_vec = data_objec['lattice']
    recip_vec = data_objec['reciprocal_lattice']
    qpts = [phon['q-position'] for phon in data_object['phonon']]

    weights = [phon['weight'] for phon in data_object['phonon']]

    phonon_data = [phon for phon in data_object['phonon']]
    bands_data_each_qpt = [bands_data['band']
                            for bands_data in phonon_data]

    # The frequency for each band at each q-point
    freqs = np.array([ [band_data['frequency']
                            for band_data in bands_data]
                              for bands_data in bands_data_each_qpt])

    # The eigenvector for each atom for each band at each q-point
    eigenvecs = np.array([ [band_data['eigenvector']
                            for band_data in bands_data]
                              for bands_data in bands_data_each_qpt]).view(np.complex128)

    n_branches = freqs.shape[1]

    ion_type = [ion['symbol'] for ion in data_object ['points']]
    ion_r = [ion['coordinates'] for ion in data_object ['points']]
    ion_mass = [ion['mass'] for ion in data_object ['points']]

    #TODO supply units
    data_dict = {}
    data_dict['n_qpts'] = n_qpts
    data_dict['n_spins'] = NotImplemented #n_spins, electronic
    data_dict['n_branches'] = n_branches
    data_dict['fermi'] = NotImplemented #(fermi*ureg.hartree).to('eV')
    data_dict['cell_vec'] = cell_vec #(cell_vec*ureg.bohr).to('angstrom')
    data_dict['recip_vec'] = recip_vec #((reciprocal_lattice(cell_vec)/ureg.bohr).to('1/angstrom'))
    data_dict['qpts'] = qpts
    data_dict['weights'] = weights #weights
    data_dict['freqs'] = freqs #(freqs*ureg.hartree).to('eV')
    data_dict['freq_down'] = NotImplemented #(freq_down*ureg.hartree).to('eV'), electronic
    #data_dict['eigenvecs'] = eigenvecs
    data_dict['n_ions'] = n_ions
    data_dict['ion_r'] = ion_r
    data_dict['ion_type'] = ion_type

    return data_dict

def _read_bands_data(seedname='mesh', path='.'):
    """
    Reads data from a band.yaml file and
    returns it in a dictionary

    Parameters
    ----------
    seedname : str
        Seedname of file(s) to read
    path : str
        Path to dir containing the file(s), if in another directory

    Returns
    -------
    data_dict : dict
        A dict with the following keys: 'n_qpts', 'n_spins', 'n_branches',
        'fermi', 'cell_vec', 'recip_vec', 'qpts', 'weights', 'freqs',
        'freq_down'. If a .castep file is available to read, the keys 'n_ions',
        'ion_r' and 'ion_type' are also present.
    """
    #TODO fix documentation

    # This defines unassigned defaults
    data_dict = {}
    data_dict['n_ions'] = None #n_ions
    data_dict['n_branches'] = None #n_branches
    data_dict['n_qpts'] = None #n_qpts
    data_dict['cell_vec'] = None #cell_vec*ureg.angstrom
    data_dict['recip_vec'] = None #reciprocal_lattice(cell_vec)/ureg.angstrom
    data_dict['ion_r'] = None #ion_r
    data_dict['ion_type'] = None #ion_type
    data_dict['ion_mass'] = None #ion_mass*ureg.amu
    data_dict['qpts'] = None #qpts
    data_dict['weights'] = None #weights
    data_dict['freqs'] = None #(freqs*(1/ureg.cm)).to('meV', 'spectroscopy')
    data_dict['eigenvecs'] = None #eigenvecs
    data_dict['split_i'] = None #split_i
    data_dict['split_freqs'] = None #(split_freqs*(1/ureg.cm)).to('meV', 'spectroscopy')
    data_dict['split_eigenvecs'] = None #split_eigenvecs

    if path:
        if not os.path.exists(path):
            raise FileNotFoundError(f'Phonopy seed path {path} does not exist.')
    else:
        path = '.'

    phonopy_files = os.listdir(path)


    #TODO merge unassigned defaults with returned data_dict
    #TODO is this a sane approach?
    def _get_file_data(file):
        try:
            with h5py.File(file) as hdf5_data:
                return _extract_bands_data(hdf5_data)
        except:
            pass

        try:
            with open(file) as yaml_obj:
                yaml_data = yaml.safe_load(yaml_obj)
                return _extract_bands_data(yaml_data)
        except:
            pass

        return None

    k = [_get_file_data(path, seedname + ext) for ext in HDF5_EXTS + YAML_EXTS]
    if any(k):
        return next(item for item in k if item is not None)


    return None

